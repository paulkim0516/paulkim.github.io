<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - GLTFloader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->

		<script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
                }
            }
        </script>

		<script type="module">

			// import * as THREE from 'three';

			// import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			// import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			// import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

			// let camera, scene, renderer;

			// init();
			// render();

			// function init() {

			// 	const container = document.createElement( 'div' );
			// 	document.body.appendChild( container );

			// 	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
			// 	camera.position.z = 50;

			// 	scene = new THREE.Scene();

			// 	scene.add(new THREE.AmbientLight(0xffffff));

			// 	const length = 12, width = 8;

			// 	const shape = new THREE.Shape();
			// 	shape.moveTo( 0,0 );
			// 	shape.lineTo( 0, width );
			// 	shape.lineTo( length, width );
			// 	shape.lineTo( length, 0 );
			// 	shape.lineTo( 0, 0 );

			// 	const extrudeSettings = {
			// 		steps: 2,
			// 		depth: 16,
			// 		bevelEnabled: true,
			// 		bevelThickness: 1,
			// 		bevelSize: 1,
			// 		bevelOffset: 0,
			// 		bevelSegments: 1
			// 	};

			// 	const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
			// 	const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			// 	const mesh = new THREE.Mesh( geometry, material ) ;
			// 	scene.add( mesh );

			// 	renderer = new THREE.WebGLRenderer( { antialias: true } );
			// 	renderer.setPixelRatio( window.devicePixelRatio );
			// 	renderer.setSize( window.innerWidth, window.innerHeight );
			// 	renderer.toneMapping = THREE.ACESFilmicToneMapping;
			// 	renderer.toneMappingExposure = 1;
			// 	renderer.outputEncoding = THREE.sRGBEncoding;
			// 	container.appendChild( renderer.domElement );

			// 	window.addEventListener( 'resize', onWindowResize );
			// }

			// function onWindowResize() {

			// 	camera.aspect = window.innerWidth / window.innerHeight;
			// 	camera.updateProjectionMatrix();

			// 	renderer.setSize( window.innerWidth, window.innerHeight );

			// 	render();

			// }

			//

			// function render() {

			// 	renderer.render( scene, camera );

			// }

			// import * as THREE from 'three';

			// let tolerance = 0.001;
			// let start = 0;
			// let end = 1;
			// let sampleNum = 20;

			// let tSampled = [];
			// let sampled = [];
			// let idx;
			// console.log(tolerance < (end - start) / sampleNum);

			// let point = new THREE.Vector3();

			// let curveGeo = new THREE.CubicBezierCurve3(
			// 	new THREE.Vector3(98.61,    343.47, 0),
			// 	new THREE.Vector3(497.41,   519.31, 0),
			// 	new THREE.Vector3(650.08,   21.31,  0),
			// 	new THREE.Vector3(925.52,   321.77, 0)
			// );

			// while (tolerance < (end - start) / sampleNum) {
			// 	tSampled = [];
			// 	sampled = [];

			// 	for (let param = start; param <= end; param += (end - start) / sampleNum) {
			// 		tSampled.push(param);
			// 		let pointOnCurve = curveGeo.getPointAt(param);
			// 		sampled.push(point.distanceTo(pointOnCurve));
			// 	}

			// 	console.log(tSampled);
			// 	console.log(sampled);

			// 	idx = sampled.indexOf(Math.min(...sampled));

			// 	if (idx === 0 || sampled[idx + 1] < sampled[idx - 1]) {
			// 		console.log((end - start) / sampleNum);
			// 		console.log(tSampled[idx]);
			// 		console.log(tSampled[idx + 1]);
			// 		start = tSampled[idx];
			// 		end = tSampled[idx + 1];
			// 	} else {
			// 		console.log((end - start) / sampleNum);
			// 		console.log(tSampled[idx - 1]);
			// 		console.log(tSampled[idx]);
			// 		start = tSampled[idx - 1];
			// 		end = tSampled[idx];
			// 	}
			// }

			// const scene = new THREE.Scene();
			// const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			// const renderer = new THREE.WebGLRenderer();
			// renderer.setSize( window.innerWidth, window.innerHeight );
			// document.body.appendChild( renderer.domElement );

			// const geometry = new THREE.BoxGeometry( 1, 1, 1 );
			// const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			// const cube = new THREE.Mesh( geometry, material );
			// // scene.add( cube );

			

			// scene.add(new THREE.AmbientLight(0xffffff));

			// const length = 12, width = 8;

			// const shape = new THREE.Shape();
			// shape.moveTo( 0,0 );
			// shape.lineTo( 0, width );
			// shape.lineTo( length, width );
			// shape.lineTo( length, 0 );
			// shape.lineTo( 0, 0 );

			// const extrudeSettings = {
			// 	steps: 2,
			// 	depth: 16,
			// 	bevelEnabled: true,
			// 	bevelThickness: 1,
			// 	bevelSize: 1,
			// 	bevelOffset: 0,
			// 	bevelSegments: 1
			// };

			// let innerWidth = window.innerWidth;
			// let innerHeight = window.innerHeight;

			// const cpPreset = [
			// 	[
			// 		new THREE.Vector3(98.61,    343.47, 0),
			// 		new THREE.Vector3(497.41,   519.31, 0),
			// 		new THREE.Vector3(650.08,   21.31,  0),
			// 		new THREE.Vector3(925.52,   321.77, 0)
			// 	],
			// 	[
			// 		new THREE.Vector3(452.88,   20.12,  0),
			// 		new THREE.Vector3(727.13,   386.20, 0),
			// 		new THREE.Vector3(341.59,   506.30, 0),
			// 		new THREE.Vector3(854.38,   611.25, 0)
			// 	],
			// 	[
			// 		new THREE.Vector3(147.75,   19.29,  0),
			// 		new THREE.Vector3(610.11,   335.64, 0),
			// 		new THREE.Vector3(68.27,    420.08, 0),
			// 		new THREE.Vector3(515.40,   679.47, 0)
			// 	]
			// ];

			// let ratio = 1;

			// if (innerWidth / 956 < innerHeight / 722) {
			// 	ratio = innerWidth / 956;
			// } else {
			// 	ratio = innerHeight / 722;
			// }
			// cpPreset.forEach(curveCP => {
			// 	curveCP.forEach(cp => {
			// 		cp.add(new THREE.Vector3(-956/2, -722/2,0)).multiplyScalar(ratio);
			// 	});
			// });

			// let curves = new THREE.Group();

			// cpPreset.forEach(curveCP => {
			// 	const curve = new THREE.CubicBezierCurve3(...curveCP);
				
			// 	const tubeGeo = new THREE.TubeGeometry(curve, 20, 20, 8, false);
			// 	tubeGeo.scale(0.2, 0.2, 0.2);
			// 	const tubeMat = new THREE.MeshBasicMaterial( { color: 0x550000 } );
			// 	const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
			// 	const tubeLine = new THREE.LineSegments(tubeGeo, new THREE.LineBasicMaterial( { color: 0xff0000} ));
			// 	curves.add(tubeLine);
			// 	curves.add(tubeMesh);

			// 	// const points = curve.getPoints(50);
			// 	// const geo = new THREE.BufferGeometry().setFromPoints(points);
			// 	// const mat = new THREE.LineBasicMaterial({ color: 0xff0000 });
			// 	// curves.add(new THREE.Line( geo, mat ));

			// 	// console.log(curve);
			// });

			// const geometry2 = new THREE.ExtrudeGeometry( shape, extrudeSettings );
			// geometry2.center();
			// const material2 = new THREE.MeshBasicMaterial( { color: 0x156289 } );
			// const mesh = new THREE.Mesh( geometry2, material2 ) ;
			// const lineSegments = new THREE.LineSegments(geometry2, new THREE.LineBasicMaterial( { color: 0xffffff }));
			// scene.add( mesh );
			// scene.add(lineSegments);
			// scene.add(curves);

			// camera.position.z = 50;

			// function animate() {
			// 	requestAnimationFrame( animate );

			// 	// cube.rotation.x += 0.01;
			// 	// cube.rotation.y += 0.01;

			// 	mesh.rotation.x += 0.01;
			// 	mesh.rotation.y += 0.01;

			// 	curves.rotation.x += 0.01;
			// 	curves.rotation.y += 0.01;

			// 	lineSegments.rotation.x += 0.01;
			// 	lineSegments.rotation.y += 0.01;

			// 	renderer.render( scene, camera );
			// }

			// animate();

			function CircleData(x, y, z, rD, gD, bD, r, g, b, radius) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.rD = rD;
				this.gD = gD;
				this.bD = bD;
				this.r = r;
				this.g = g;
				this.b = b;
				this.radius = radius;
				this.getHex = () => {
					return this.r * 0x010000 + this.g * 0x000100 + this.b;
				}

				this.clone = () => {
					return new CircleData(this.x, this.y, this.z, this.rD, this.gD, this.bD, this.r, this.g, this.b, this.radius);
				}
			}

			let a = new CircleData(1,2,3,4,5,6,7,8,9,10);
			console.log(a);
			let b = a.clone();
			console.log(b);
			b.rD = 999;
			console.log(a);
			console.log(b);


		</script>

	</body>
</html>