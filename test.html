<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Three.js Example</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let camera, scene, renderer;
        let raycaster;
        let controls;
        let gui;
        const fov = 75;
        const near = 0.1;
        const far = 1000;

        let closestPlaneDist = 0;

        const boxDim = 4;
        const sphereRadius = 0.2;

        let box, sphere, center;
        let prevTime = 0;
        let velocity = new THREE.Vector3(0.001, 0.002, 0.003);
        // let velocity = new THREE.Vector3(0, 0.004, 0);

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, near, far);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            raycaster = new THREE.Raycaster();

            const pointLight = new THREE.PointLight(0xffffff, 1, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);

            const ambient = new THREE.AmbientLight(0xffffff, 0.01);
            // scene.add(ambient);
            setupGeometry();
            buildInfoMenu();
        }

        function buildInfoMenu() {
            gui = new GUI();
            const params = {
                gravity: center.visible,
                speed: Math.round(velocity.length),
                x: sphere.position.x,
                y: sphere.position.y,
                z: sphere.position.z,
                s0: 'null'
            };

            gui.add(params, 'gravity').onChange(v => {
                center.visible = v;
                // console.log(enableGravity);
                // animate();
            });
            gui.add(params, 'speed').disable();
            gui.add(params, 'x').disable();
            gui.add(params, 'y').disable();
            gui.add(params, 'z').disable();
            gui.add(params, 's0').disable();
        }

        function setupGeometry() {
            center = new THREE.Mesh(new THREE.SphereGeometry(0.05, 32, 32), new THREE.MeshPhongMaterial({ color: 0x222222 }));
            scene.add(center);
            console.log(center);
            // box = new THREE.Mesh(new THREE.BoxGeometry(boxDim, boxDim, boxDim), new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.BackSide, transparent: true, opacity: 0.5 }));
            box = new THREE.Mesh(new THREE.OctahedronGeometry(boxDim), new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.BackSide, transparent: true, opacity: 0.5 }));
            box.receiveShadow = true;
            box.rotation.y = Math.PI;
            box.material.shadowSide = THREE.DoubleSide;
            box.material.color.set(Math.round(Math.random() * 0x79 + 0x80) * 0x010000 + Math.round(Math.random() * 0x79 + 0x80) * 0x000100 + Math.round(Math.random() * 0x79 + 0x80) * 0x000001);
            scene.add(box);
            let floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshLambertMaterial({ color: 0x444444 }));
            floor.position.y = -2.2;
            floor.rotation.x = - Math.PI / 2;
            floor.receiveShadow = true;
            // scene.add(floor);
            sphere = new THREE.Mesh(new THREE.SphereGeometry(sphereRadius, 128, 128), new THREE.MeshPhongMaterial({ color: 0xffffff }));
            sphere.position.set(-1.5, 0, 0);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
        }

        function checkIntersects(mesh) {
            const intersects = [];
            const intersectedNormals = [];
            raycaster.set(mesh.position, new THREE.Vector3(0, 0, -1));
            intersects.push(...raycaster.intersectObject(box));
            raycaster.set(mesh.position, new THREE.Vector3(0, 0, 1));
            intersects.push(...raycaster.intersectObject(box));
            raycaster.set(mesh.position, new THREE.Vector3(0, -1, 0));
            intersects.push(...raycaster.intersectObject(box));
            raycaster.set(mesh.position, new THREE.Vector3(0, 1, 0));
            intersects.push(...raycaster.intersectObject(box));
            raycaster.set(mesh.position, new THREE.Vector3(-1, 0, 0));
            intersects.push(...raycaster.intersectObject(box));
            raycaster.set(mesh.position, new THREE.Vector3(1, 0, 0));
            intersects.push(...raycaster.intersectObject(box));
            intersects.forEach(intersect => {
                if (mesh.position.distanceTo(intersect.point) <= mesh.geometry.parameters.radius + 0.01) intersectedNormals.push(intersect.face.normal.normalize());
            });
            return intersectedNormals;
        }

        function getAcceleration(mesh) {
            const acceleration = mesh.position.clone().negate().normalize();
            const centerMass = 10;

            // acceleration.multiplyScalar(centerMass / mesh.position.lengthSq() * 0.000001);
            acceleration.multiplyScalar(0.00001);

            return mesh.position.length() > 0.05 ? acceleration : new THREE.Vector3(Math.random() * 0.001, Math.random() * 0.001, Math.random() * 0.001);
        }

        function animate(timestamp) {
            requestAnimationFrame(animate);
            const elapsedTime = timestamp - prevTime;

            const normalized = checkIntersects(sphere);
            if (normalized.length != 0) {
                normalized.forEach(normal => {
                    let dotProduct = velocity.dot(normal);
                    velocity.sub(normal.clone().multiplyScalar(2 * dotProduct));
                });
            }

            if (!isNaN(elapsedTime)) {
                sphere.position.add(velocity.clone().multiplyScalar(elapsedTime));
                if (center.visible) {
                    const acc = getAcceleration(sphere);
                    sphere.position.add(acc.clone().multiplyScalar(Math.pow(elapsedTime, 2) / 2));
                    velocity.add(acc.clone().multiplyScalar(elapsedTime));
                }
            }

            if (velocity.length() > 0.015) {
                console.log(velocity);
                velocity.normalize().multiplyScalar(0.01);
                console.log(velocity);
            }

            if (sphere.position.x > boxDim / 2) {
                sphere.position.x = boxDim / 2 - sphereRadius - 0.05;
                if (velocity.x > 0) {
                    let normal = new THREE.Vector3(-1, 0, 0);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            } else if (sphere.position.x < -boxDim / 2) {
                sphere.position.x = -boxDim / 2 + sphereRadius + 0.05;
                if (velocity.x < 0) {
                    let normal = new THREE.Vector3(1, 0, 0);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            }
            if (sphere.position.y > boxDim / 2) {
                sphere.position.y = boxDim / 2 - sphereRadius - 0.05;
                if (velocity.y > 0) {
                    let normal = new THREE.Vector3(0, -1, 0);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            } else if (sphere.position.y < -boxDim / 2) {
                sphere.position.y = -boxDim / 2 + sphereRadius + 0.05;
                if (velocity.y < 0) {
                    let normal = new THREE.Vector3(0, 1, 0);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            }
            if (sphere.position.z > boxDim / 2) {
                sphere.position.z = boxDim / 2 - sphereRadius - 0.05;
                if (velocity.z > 0) {
                    let normal = new THREE.Vector3(0, 0, -1);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            } else if (sphere.position.z < -boxDim / 2) {
                sphere.position.z = -boxDim / 2 + sphereRadius + 0.05;
                if (velocity.z < 0) {
                    let normal = new THREE.Vector3(0, 0, 1);
                    let dotProduct = velocity.dot(normal);
                    velocity.reflect(normal);
                }
            }

            prevTime = timestamp;
            render();
            closestPlaneDist = closestPlane();
        }

        function closestPlane() {
            let minDist = Infinity;
            const index = box.geometry.getIndex();
            const position = box.geometry.attributes.position.array;
            if (index) {
                for (let i = 0; i < index.count; i += 3) {
                    let v1 = new THREE.Vector3(position[index.array[i]*3], position[index.array[i]*3+1], position[index.array[i]*3+2]);
                    let v2 = new THREE.Vector3(position[index.array[i+1]*3], position[index.array[i+1]*3+1], position[index.array[i+1]*3+2]);
                    let v3 = new THREE.Vector3(position[index.array[i+2]*3], position[index.array[i+2]*3+1], position[index.array[i+2]*3+2]);
                    
                    const plane = new THREE.Plane();
                    plane.setFromCoplanarPoints(v1, v2, v3);
                    minDist = Math.min(minDist, Math.abs(plane.distanceToPoint(sphere.position)));
                }
            } else {
                for (let i = 0; i < position.length; i+=9) {
                    let v1 = new THREE.Vector3(position[i], position[i + 1], position[i + 2]);
                    let v2 = new THREE.Vector3(position[i + 3], position[i + 4], position[i + 5]);
                    let v3 = new THREE.Vector3(position[i + 6], position[i + 7], position[i + 8]);
                    
                    const plane = new THREE.Plane();
                    plane.setFromCoplanarPoints(v1, v2, v3);
                    minDist = Math.min(minDist, Math.abs(plane.distanceToPoint(sphere.position)));
                }
            }

            // console.log(closestPlaneDist);
            return minDist;
        }

        function render() {
            controls.update();
            gui.controllers[1].setValue(velocity.length());
            gui.controllers[2].setValue(sphere.position.x);
            gui.controllers[3].setValue(sphere.position.y);
            gui.controllers[4].setValue(sphere.position.z);
            gui.controllers[5].setValue(closestPlaneDist);
            renderer.render(scene, camera);
        }

        init();
        animate();
        console.log(box);
        const normalArr = box.geometry.attributes.position;
        console.log(normalArr);

    </script>
</body>

</html>